syntax = "proto3";

package proto;

option go_package = "github.com/clintjedwards/gofer/proto";

// Documentation for these models can be found in the "models" package as these
// are just protobuf representations of those models.
//
// Why represent what amounts to the same model twice in protobuf AND a struct
// you ask?
//
//   Essentially, because the separation of the transport layer and the
//   application layer is a good thing. There are probably many reasons, but
//   the most straightforward is that we might want to represent something in
//   the database or within the application that might not be easily
//   representable in protobuf, a structure mainly made for transport.
//
//   There might also be things that we don't want to expose outside and so
//   the separation gives us a chance to not mess that up by simply forgetting a
//   json:"-".

message Namespace {
  string id = 1;
  string name = 2;
  string description = 3;
  uint64 created = 4;
  uint64 modified = 5;
}

enum VariableOwner {
  UNKNOWN = 0;
  USER = 1;
  SYSTEM = 2;
}
message Variable {
  string key = 1;
  string value = 2;
  VariableOwner owner = 3;
}

message Pipeline {
  string namespace = 1;
  string id = 2;
  string name = 3;
  string description = 4;
  uint64 last_run_id = 5;
  uint64 last_run_time = 6;
  uint64 parallelism = 7;
  uint64 created = 8;
  uint64 modified = 9;
  enum PipelineState {
    PIPELINE_STATE_UNKNOWN = 0;
    ACTIVE = 1;
    DISABLED = 2;
  }
  PipelineState state = 10;
  map<string, Task> tasks = 11;
  map<string, PipelineTriggerSettings> triggers = 12;
  map<string, PipelineNotifierSettings> notifiers = 13;
  repeated string store_keys = 14;
}

message PipelineConfig {
  string id = 1;
  string name = 2;
  string description = 3;
  uint64 parallelism = 4;
  map<string, Task> tasks = 5;
  map<string, PipelineTriggerSettings> triggers = 6;
  map<string, PipelineNotifierSettings> notifiers = 7;
}

message Run {
  string namespace = 1;
  string pipeline = 2;
  uint64 id = 3;
  uint64 started = 4;
  uint64 ended = 5;
  enum RunState {
    RUN_STATE_UNKNOWN = 0;
    PENDING = 1;
    RUNNING = 2;
    COMPLETE = 3;
  }
  RunState state = 6;
  enum RunStatus {
    RUN_STATUS_UNKNOWN = 0;
    SUCCESSFUL = 1;
    FAILED = 2;
    CANCELLED = 3;
  }
  RunStatus status = 7;
  RunFailureInfo failure_info = 8;
  repeated string task_runs = 9;
  RunTriggerInfo trigger = 10;
  repeated Variable variables = 11;
  RunStoreInfo store_info = 12;
}

message RunFailureInfo {
  enum RunFailureReason {
    RUN_FAILURE_REASON_UNKNOWN = 0;
    ABNORMAL_EXIT = 1;
    SCHEDULER_ERROR = 2;
    FAILED_PRECONDITION = 3;
    USER_CANCELLED = 4;
    ADMIN_CANCELLED = 5;
  }
  RunFailureReason reason = 1;
  string description = 2;
}

message RunTriggerInfo {
  string kind = 1;
  string label = 2;
}

message RunStoreInfo {
  bool is_expired = 1;
  repeated string keys = 2;
}

message RegistryAuth {
  string user = 1;
  string pass = 2;
}

message Exec {
  string shell = 1;
  string script = 2;
}

message Task {
  string namespace = 1;
  string pipeline = 2;
  string id = 3;
  string description = 4;
  string image = 5;
  RegistryAuth registry_auth = 6;
  enum RequiredParentStatus {
    REQUIRED_PARENT_STATUS_UNKNOWN = 0;
    ANY = 1;
    SUCCESS = 2;
    FAILURE = 3;
  }
  map<string, RequiredParentStatus> depends_on = 7;
  repeated Variable variables = 8;
  Exec exec = 9;
}

message PipelineTriggerSettings {
  string kind = 1;
  string label = 2;
  map<string, string> settings = 3;
  string error = 4;
}

message PipelineNotifierSettings {
  string kind = 1;
  string label = 2;
  map<string, string> settings = 3;
  string error = 4;
}
